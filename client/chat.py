import asyncio
import websockets
from aioconsole import ainput
import logging
from shared.protocol import encode_message, decode_message

# === Configuration === #
SERVER_URI = "ws://localhost:8765"

logging.basicConfig(
    level=logging.INFO,
    format= "%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%H:%M:%S"
    )
logger = logging.getLogger(__name__)
# ===================== #



# Helper method for confirming exit
# Async input for confirmation (still works fine with ainput)
async def confirm_exit() -> bool:
    """ Prompt the user to confirm if they really want to exit """

    while True:
        response = await ainput("\n Confirm your will to exit (y/n) ")
        response = response.strip().lower()
        if response == "y":
            return True
        elif response == "n":
            logger.info(msg="[confirm_exit] Resuming chat. User decided not to exit.")
            return False
        else:
            logger.warning("You have to enter something [y/n]. come on -_-")

async def safe_input(prompt: str = "") -> str | None:
    """ Safe input wrapper with exception handling for keyboard interrupts and EOF errors as well as natively async input handling so to not block the event loop. (eliminates the need for spawning threads) """

    try:
        return await ainput(prompt)
    
    except (KeyboardInterrupt, EOFError):
        logger.warning(" [safe_input] keyboard interrupt or EOF detected")
        return None # signal that we are interuppted

async def send_messages(websocket: websockets.ClientConnection, username: str):
    """ 
    Handles sending messages through the websocket.
    
    This coroutine runs as a task and handles user input in a loop.
    If the user types `/exit`, it raises a `CancelledError` to signal shutdown
    to the event loop and other concurrent tasks.
    """

    while True:
        try:
            message = await safe_input()
            
            # we caught KeyboardInterrupt from inside the thread
            if message is None:
                logger.info("[send_messages] Input interrupted. Exiting message loop.")
                break
            
            # Handle custom commands
            elif message.strip().startswith("/"):
                
                if message.strip() == "/exit":
                    should_exit = await confirm_exit()
                    
                    if should_exit:        
                        logger.info("[send_messages] User confirmed exit. Cancelling task.")

                        # This exception is raised when the /exit is processed and confirmed from the send_messages() 
                        # which raises and propogates `exception of the same` up-ward towards the event loop 
                        # alerting any other tasks that catches this exception to handle the cancelling.
                        # Even if any tasks miss this signal, there is a preventative measure to cancel all the tasks in the main method                        
                        raise asyncio.CancelledError
                    
                    else:
                        continue
            
            # Send the message if everything is fine
            else:
                encoded = encode_message(message=message, sender=username)
                await websocket.send(encoded)

        # Precautionary Exception
        except KeyboardInterrupt:
            # Most likely this exception won't be caught
            # This exception would be generated by the input thread in the above try block and handled via the safe_input() method.
            
            logger.warning("[send_messages] KeyboardInterrupt caught unexpectedly.")
            break

        except asyncio.CancelledError:
            logger.info("[send_messages] Task cancelled cleanly.")
            raise

async def receive_messages(websocket):
    """ Handles receiving and decoding messages from the websocket. """

    while True:

        try:
            message = await websocket.recv()
            decoded = decode_message(message_str=message)
            print(f"\n [{decoded['timestamp']}] {decoded['sender']}: {decoded['message']}")

        except websockets.exceptions.ConnectionClosed:
            # This exception occurs when a keyboard interrupt is experienced 
            # which first interrupts the event_loop where the websocket connection is 
            # terminated and as a side effect this exception is recognised.
            
            logger.warning("[receive_messages] Websocket connection closed from/by server")
            return

        except asyncio.CancelledError:
            # When this task detects the propogation of cancellation signal in the event loop.

            logger.info("[receive_messages] Task received cancellation signal.")
            raise

async def main(username: str | None = None):
    """ Main event loop handling input/output task coordination and handle the following tasks:
    1. send_messages
    2. receive_messages
    """

    if username == None:

        # Get the username until the user enters a non-empty value
        while True:
            username = await ainput("\n Enter your username: ")
            if username:
                username = username.strip()
                break
            if not username:
                logger.warning("[main] Username cannot be empty... come on bro! :/")
    
    # Connect to the websocket server via async context manager
    async with websockets.connect(SERVER_URI) as websocket:
        logger.info(f"Connected to secure chat websocket server at ws://localhost:8765 as '{username}'")
        send_task = asyncio.create_task(send_messages(websocket, username))
        receive_task = asyncio.create_task(receive_messages(websocket))


        try:

            # Process the tasks by waiting them accordingly
            done, pending = await asyncio.wait(
                [send_task, receive_task],
                return_when=asyncio.FIRST_COMPLETED
            )

            # Cancel other tasks that did not finish
            for task in pending:
                
                task.cancel()
                
                try:
                    await task
                    
                except asyncio.CancelledError:
                    logger.info(f"[main] Cancelled pending task: {task.get_coro().__name__}")  # type: ignore    
            
            # Get the exceptions of tasks which have not been handled appropriately 
            for task in done:
                if task.exception():
                    logger.error(f"[main] Exception from task {task.get_coro().__name__} raised: {task.exception()}") # type: ignore 
                    raise task.exception() # type: ignore
                
        except asyncio.CancelledError:
            logger.info("[main] Main task cancelled.")
            raise

        except websockets.exceptions.ConnectionClosed:
            logger.warning("[main] Server closed the connection. Press 'Enter' to finish exiting")
            raise

        finally:
            logger.info("[main] All tasks completed or cancelled. Exiting Gracefully")


if __name__ == "__main__":
    """ Run the event loop / manager. Entry point for chat client. """
    
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.warning("[root] Keyboard interrupt detected. Client shutting down :(")
    except ConnectionRefusedError:
        logger.error("[root] Connection refused - server may be offline :(")
    except asyncio.CancelledError:
        logger.info("[root] Shutdown handled via cancellation.")
    except websockets.exceptions.ConnectionClosed:
        logger.info("[root] Connection Sucessfully Closed.")
    